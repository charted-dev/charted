// üêª‚Äç‚ùÑÔ∏èüì¶ charted-server: Free, open source, and reliable Helm Chart registry made in Rust
// Copyright 2022-2025 Noelware, LLC. <team@noelware.org>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use super::*;
use utoipa::openapi::{
    Ref, RefOr, Schema, Type,
    path::ParameterIn,
    schema::{AdditionalProperties, ArrayItems, SchemaType},
};

#[test]
fn update_paths_to_include_default_api_version() {
    // a dummy route that exists
    #[utoipa::path(get, path = "/v1/weow")]
    #[allow(dead_code)]
    fn dummy_route() {}

    #[utoipa::path(get, path = "/v1")]
    #[allow(dead_code)]
    fn other_dummy_route() {}

    #[derive(OpenApi)]
    #[openapi(paths(dummy_route, other_dummy_route), modifiers(&IncludeDefaultVersionWithoutPrefix))]
    struct Document;

    let openapi = Document::openapi();
    let paths = openapi.paths.paths.keys().collect::<Vec<_>>();

    assert_eq!(&paths, &["/", "/v1", "/v1/weow", "/weow"]);
}

#[test]
fn sanity_check_all_references_are_correct() {
    let mut references = Vec::new();
    let document = Document::openapi();

    let components = unsafe { document.components.clone().unwrap_unchecked() };
    let paths = document.paths.paths.clone();

    fn recursive_schema_collect(
        references: &mut Vec<(String, Ref)>,
        toplevel: &str,
        name: String,
        schema: RefOr<Schema>,
    ) {
        let schema = match schema {
            RefOr::T(schema) => schema,
            RefOr::Ref(ref_) => {
                references.push((format!("{toplevel}.{name}"), ref_.clone()));
                return;
            }
        };

        match schema {
            Schema::Object(object) => {
                // if we are not the object primitive, it's pretty useless for this test
                if object.schema_type != SchemaType::Type(Type::Object) {
                    return;
                }

                // For all the properties in the object, let's check if
                // any of them are references
                for (prop, property) in object.properties.iter() {
                    match property {
                        RefOr::T(schema) => {
                            recursive_schema_collect(
                                references,
                                toplevel,
                                format!("{name}.{prop}"),
                                RefOr::T(schema.clone()),
                            );
                        }

                        RefOr::Ref(ref_) => {
                            references.push((format!("property|{toplevel}.{name}.{prop}"), ref_.clone()));
                            continue;
                        }
                    }
                }

                // Check the additional properties as well
                match object.additional_properties.clone() {
                    None => {}
                    Some(additional) => match &*additional {
                        AdditionalProperties::FreeForm(_) => {}
                        AdditionalProperties::RefOr(RefOr::T(schema)) => {
                            recursive_schema_collect(
                                references,
                                toplevel,
                                format!("{name}[additionalProperties]"),
                                RefOr::T(schema.clone()),
                            );
                        }

                        AdditionalProperties::RefOr(RefOr::Ref(ref_)) => {
                            references.push((format!("additionalProperties|{toplevel}.{name}"), ref_.clone()));
                        }
                    },
                }
            }

            Schema::Array(array) => {
                assert!(
                    array.items != ArrayItems::False,
                    "schemas of array types should never return `false`."
                );

                // Safety: we already know that `ArrayItems` will never return `ArrayItems::False`:
                //
                //    - Assertion above
                //    - All array-based items generated by utoipa-gen will never
                //      use `ArrayItems::False`.
                //
                // so we can just translate `ArrayItems` -> `Box<RefOr<Schema>>` since we are always in the
                // `ArrayItems::RefOr(...)` discriminant.
                //
                // ## Why the unsafety?!
                // I am very sure that it'll return a schema and a match statement here would be
                // even more messy.
                let schema = unsafe { std::mem::transmute::<ArrayItems, Box<RefOr<Schema>>>(array.items) };
                recursive_schema_collect(references, toplevel, format!("{name}|array"), (*schema).clone());
            }

            Schema::OneOf(oneof) => {
                for (i, item) in oneof.items.iter().cloned().enumerate() {
                    match item {
                        RefOr::T(schema) => {
                            recursive_schema_collect(
                                references,
                                toplevel,
                                format!("{name}[oneOf]"),
                                RefOr::T(schema),
                            );
                        }

                        RefOr::Ref(ref_) => {
                            references.push((format!("{i}|{toplevel}.{name}[oneOf]"), ref_));
                        }
                    }
                }
            }

            Schema::AnyOf(anyof) => {
                for (i, item) in anyof.items.iter().cloned().enumerate() {
                    match item {
                        RefOr::T(schema) => {
                            recursive_schema_collect(
                                references,
                                toplevel,
                                format!("{name}[anyOf]"),
                                RefOr::T(schema),
                            );
                        }

                        RefOr::Ref(ref_) => {
                            references.push((format!("{i}|{toplevel}.{name}[anyOf]"), ref_));
                        }
                    }
                }
            }

            Schema::AllOf(allof) => {
                for (i, item) in allof.items.iter().cloned().enumerate() {
                    match item {
                        RefOr::T(schema) => {
                            recursive_schema_collect(
                                references,
                                toplevel,
                                format!("{name}[allOf]"),
                                RefOr::T(schema),
                            );
                        }

                        RefOr::Ref(ref_) => {
                            references.push((format!("{i}|{toplevel}.{name}[allOf]"), ref_));
                        }
                    }
                }
            }

            _ => {}
        }
    }

    // Recurse through all schemas
    for (name, schema) in components.schemas.iter() {
        recursive_schema_collect(&mut references, "components.schemas", name.clone(), schema.clone());
    }

    // Recurse through all responses' content (since they're schemas!)
    for (name, response) in components.responses.iter() {
        let response = match response {
            RefOr::T(resp) => resp,
            RefOr::Ref(ref_) => {
                references.push((format!("components.responses.{name}"), ref_.clone()));
                continue;
            }
        };

        for (type_, content) in response.content.iter() {
            if let Some(schema) = content.schema.as_ref() {
                match schema {
                    RefOr::T(schema) => recursive_schema_collect(
                        &mut references,
                        &format!("components.responses.{name}.content"),
                        type_.clone(),
                        RefOr::T(schema.clone()),
                    ),

                    RefOr::Ref(ref_) => {
                        references.push((format!("components.responses.{name}.content[{type_}]"), ref_.clone()));
                        continue;
                    }
                }
            }
        }
    }

    for (path, item) in paths {
        // go through all operations in this path
        for (opname, op) in [
            ("get", item.get),
            ("post", item.post),
            ("patch", item.patch),
            ("delete", item.delete),
            ("put", item.put),
        ]
        .iter()
        .filter_map(|(name, op)| op.as_ref().map(|op| (name, op)))
        {
            for (status, response) in op.responses.responses.iter() {
                let response = match response {
                    RefOr::T(resp) => resp,
                    RefOr::Ref(ref_) => {
                        references.push((format!("paths.{path}.{opname}.responses.{status}"), ref_.clone()));
                        continue;
                    }
                };

                for (type_, content) in response.content.iter() {
                    if let Some(schema) = content.schema.as_ref() {
                        match schema {
                            RefOr::T(schema) => recursive_schema_collect(
                                &mut references,
                                &format!("paths.{path}.{opname}.responses.{status}.content"),
                                type_.clone(),
                                RefOr::T(schema.clone()),
                            ),

                            RefOr::Ref(ref_) => {
                                references.push((
                                    format!("paths.{path}.{opname}.responses.{status}.content[{type_}]"),
                                    ref_.clone(),
                                ));

                                continue;
                            }
                        }
                    }
                }
            }
        }

        // go through all parameters
        if let Some(params) = item.parameters {
            for param in params {
                let kind = match param.parameter_in {
                    ParameterIn::Path => "parameter.path",
                    ParameterIn::Query => "parameter.query",
                    ParameterIn::Header => "header",
                    ParameterIn::Cookie => "cookie",
                };

                if let Some(schema) = param.schema {
                    match schema {
                        RefOr::T(schema) => {
                            recursive_schema_collect(
                                &mut references,
                                &format!("paths.{path}.{kind}"),
                                param.name,
                                RefOr::T(schema),
                            );
                        }

                        RefOr::Ref(ref_) => {
                            references.push((format!("paths.{path}.{kind}.{}", param.name), ref_));
                        }
                    }
                }
            }
        }
    }

    eprintln!("received {} references", references.len());

    let as_json_value = serde_json::to_value(document).unwrap();
    for (name, ref_) in references {
        eprintln!("==> validating {} ({name})", ref_.ref_location);

        // references are usually similar to JSON pointers (kind of).
        let ptr = ref_.ref_location.replace('#', "");
        match as_json_value.pointer(&ptr) {
            Some(_) => {}
            None => panic!(
                "{name}: reference {} is non-existent or is a invalid JSON pointer ({ptr})",
                ref_.ref_location
            ),
        }
    }
}

#[test]
fn sanity_check_if_all_tags_are_correct() {
    let doc = Document::openapi();

    // we already know we have tags already -- we shouldn't have to add a
    // panic path here.
    let tags = unsafe { doc.tags.unwrap_unchecked() };

    for (path, item) in doc.paths.paths {
        for (method, op) in [
            ("get", item.get),
            ("put", item.put),
            ("post", item.post),
            ("patch", item.patch),
            ("delete", item.delete),
        ] {
            let Some(op) = op else {
                continue;
            };

            if let Some(optags) = op.tags {
                for tag in optags {
                    assert!(
                        tags.iter().any(|x| x.name == tag),
                        "operation {method} {path}: tag '{tag}' doesn't exist in openapi document"
                    );
                }
            }
        }
    }
}
