{
    "openapi": "3.0.3",
    "info": {
        "title": "charted-server",
        "description": "üêª‚Äç‚ùÑÔ∏èüì¶ Free, open source, and reliable Helm Chart registry made in Rust",
        "termsOfService": "https://charts.noelware.org/legal/tos",
        "contact": { "name": "Noelware, LLC.", "url": "https://noelware.org", "email": "team@noelware.org" },
        "license": { "name": "Apache 2.0", "url": "https://www.apache.org/licenses/LICENSE-2.0" },
        "version": "0.1.0-beta"
    },
    "servers": [
        {
            "url": "https://charts.noelware.org",
            "description": "Official home for charted-server, Noelware's public instance"
        }
    ],
    "paths": {
        "/": {
            "get": {
                "tags": ["Main"],
                "description": "Main entrypoint to charted-server. This is just a generic \"hello world\" response.",
                "operationId": "main",
                "responses": {
                    "200": {
                        "description": "Successful response",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/MainResponse" } }
                        }
                    }
                }
            }
        },
        "/apikeys": {
            "get": {
                "tags": ["API Keys"],
                "description": "Entrypoint for the API Keys API",
                "operationId": "apikeys",
                "responses": {
                    "200": {
                        "description": "Successful response",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/EntrypointResponse" } }
                        }
                    }
                }
            }
        },
        "/apikeys/all": {
            "get": {
                "tags": ["API Keys"],
                "description": "Paginate through all API keys available",
                "operationId": "list_all_apikeys",
                "responses": {
                    "200": {
                        "description": "Successful response",
                        "content": {
                            "application/json": {
                                "schema": { "$ref": "#/components/responses/ApiKeyPaginatedResponse" }
                            }
                        }
                    },
                    "400": {
                        "description": "Unable to process request query parameters",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "401": {
                        "description": "Unauthorized to process the given session details or if the JWT token had expired",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "403": {
                        "description": "Received an invalid password from the `Basic` authorization scheme",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "406": {
                        "description": "Unable to process the session due to some unexpected outcome",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    }
                }
            }
        },
        "/apikeys/{idOrName}": {},
        "/features": {
            "get": {
                "tags": ["Main"],
                "description": "Retrieve this server's features. This is only for enabling or disabling features for API consumers.",
                "operationId": "features",
                "responses": {
                    "200": {
                        "description": "Successful response",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/FeaturesResponse" } }
                        }
                    }
                }
            }
        },
        "/heartbeat": {
            "get": {
                "tags": ["Main"],
                "description": "Generic healthcheck endpoint",
                "operationId": "heartbeat",
                "responses": {
                    "200": {
                        "description": "Successful response",
                        "content": { "text/plain": { "schema": { "type": "string" } } }
                    }
                }
            }
        },
        "/index/{idOrName}": {
            "get": {
                "tags": ["Main", "Users", "Organizations"],
                "description": "Returns a index of a user or organization's Helm charts",
                "operationId": "get_chart_index",
                "parameters": [
                    {
                        "name": "idOrName",
                        "in": "path",
                        "description": "Path parameter that can take a `Name` or `Snowflake` identifier",
                        "required": true,
                        "schema": { "$ref": "#/components/schemas/NameOrSnowflake" }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Chart index for a specific user or organization",
                        "content": {
                            "text/yaml": { "schema": { "$ref": "#/components/responses/ChartIndexResponse" } }
                        }
                    },
                    "404": {
                        "description": "User or Organization was not found",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    }
                }
            }
        },
        "/info": {
            "get": {
                "tags": ["Main"],
                "description": "REST handler for getting more information about this instance that can be visible for API consumers.",
                "operationId": "info",
                "responses": {
                    "200": {
                        "description": "Successful response",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/InfoResponse" } }
                        }
                    }
                }
            }
        },
        "/organizations": {
            "get": {
                "tags": ["Organizations"],
                "description": "Entrypoint for the Organizations API",
                "operationId": "repositories",
                "responses": {
                    "200": {
                        "description": "Successful response",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/EntrypointResponse" } }
                        }
                    }
                }
            }
        },
        "/organizations/{idOrName}": {
            "get": {
                "tags": ["Organizations"],
                "description": "Finds an organization by its ID or name.",
                "operationId": "get_org_by_id_or_name",
                "parameters": [
                    {
                        "name": "idOrName",
                        "in": "path",
                        "description": "Path parameter that can take a `Name` or Snowflake ID",
                        "required": true,
                        "schema": { "$ref": "#/components/schemas/NameOrSnowflake" }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Successful response",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/OrganizationResponse" } }
                        }
                    },
                    "403": {
                        "description": "You are not allowed to see this resource",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "404": {
                        "description": "Entity was not found",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    }
                }
            }
        },
        "/organizations/{idOrName}/icon": {
            "get": {
                "tags": ["Organizations", "Icons"],
                "description": "Returns the organization's current icon. Use the [`GET /organizations/{idOrName}/icons/{hash}.png`] REST route\n to grab an organization icon by a specific hash.\n\n [`GET /organizations/{idOrName}/icons/{hash}.png`]: https://charts.noelware.org/docs/server/latest/api/reference/organizations#GET-/organizations/{idOrName}/icon/{hash}.png",
                "operationId": "get_current_org_icon",
                "parameters": [
                    {
                        "name": "idOrName",
                        "in": "path",
                        "description": "Path parameter that can take a `Name` or Snowflake ID",
                        "required": true,
                        "schema": { "$ref": "#/components/schemas/NameOrSnowflake" }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Successful response",
                        "content": { "image/*": { "schema": { "type": "string", "format": "binary" } } }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    }
                }
            }
        },
        "/organizations/{idOrName}/icon/{hash}": {
            "get": {
                "tags": ["Organizations", "Icons"],
                "description": "Return a organization icon by the icon hash.",
                "operationId": "get_org_icon_by_hash",
                "parameters": [
                    {
                        "name": "hash",
                        "in": "path",
                        "description": "the hash to lookup for",
                        "required": true,
                        "schema": { "type": "string" }
                    },
                    {
                        "name": "idOrName",
                        "in": "path",
                        "description": "Path parameter that can take a `Name` or Snowflake ID",
                        "required": true,
                        "schema": { "$ref": "#/components/schemas/NameOrSnowflake" }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Successful response",
                        "content": { "image/*": { "schema": { "type": "string", "format": "binary" } } }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    }
                }
            }
        },
        "/organizations/{idOrName}/repositories": {
            "get": {
                "tags": ["Organizations", "Repositories"],
                "description": "Retrieve all of a organization's repositories. This filters out private ones.",
                "operationId": "list_org_repositories",
                "parameters": [
                    {
                        "name": "cursor",
                        "in": "query",
                        "description": "Cursor to passthrough to proceed into the next or previous page.",
                        "required": false,
                        "schema": {
                            "type": "integer",
                            "format": "int64",
                            "description": "Unique identifier for a resource. Based off the [Twitter Snowflake](https://blog.twitter.com/engineering/en_us/a/2010/announcing-snowflake) spec.",
                            "minLength": 15
                        }
                    },
                    {
                        "name": "idOrName",
                        "in": "path",
                        "description": "Path parameter that can take a [`Name`] or [`Snowflake`] identifier.",
                        "required": true,
                        "schema": { "$ref": "#/components/schemas/NameOrSnowflake" }
                    },
                    {
                        "name": "order",
                        "in": "query",
                        "description": "Order to sort the entries by.",
                        "required": false,
                        "schema": { "$ref": "#/components/schemas/OrderBy" }
                    },
                    {
                        "name": "per_page",
                        "in": "query",
                        "description": "How many elements should be present in a page.",
                        "required": false,
                        "schema": { "type": "integer", "format": "int32" }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "List of all the organization's repositories",
                        "content": {
                            "application/json": {
                                "schema": { "$ref": "#/components/responses/RepositoryPaginatedResponse" }
                            }
                        }
                    }
                }
            }
        },
        "/repositories": {
            "get": {
                "tags": ["Repositories"],
                "description": "Entrypoint for the Repositories API",
                "operationId": "repositories",
                "responses": {
                    "200": {
                        "description": "Successful response",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/EntrypointResponse" } }
                        }
                    }
                }
            }
        },
        "/repositories/{id}": {
            "get": {
                "tags": ["Repositories"],
                "description": "Finds a repository by its ID.",
                "operationId": "get_repo_by_id",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "required": true,
                        "schema": {
                            "type": "integer",
                            "format": "int64",
                            "description": "Unique identifier for a resource. Based off the [Twitter Snowflake](https://blog.twitter.com/engineering/en_us/a/2010/announcing-snowflake) spec.",
                            "minLength": 15
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Successful response",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/RepositoryResponse" } }
                        }
                    },
                    "403": {
                        "description": "You are not allowed to see this resource",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "404": {
                        "description": "Entity was not found",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    }
                }
            }
        },
        "/repositories/{owner}/{name}": {
            "get": {
                "tags": ["Repositories"],
                "description": "Find a repository by the owner's ID/name and the repository's ID/name\n\n ## Examples\n ```http\n # Acceptable\n GET /repositories/charted/server\n\n # Not acceptable\n GET /repositories/server  # `server` will be treated as a owner's ID or name.\n GET /repositories/charted # use /[users|organizations]/repositories to list all repositories\n ```",
                "operationId": "get_repo_by_owner_and_name",
                "parameters": [
                    {
                        "name": "owner",
                        "in": "path",
                        "description": "owner's ID or name",
                        "required": true,
                        "schema": { "$ref": "#/components/schemas/NameOrSnowflake" }
                    },
                    {
                        "name": "repo",
                        "in": "path",
                        "description": "repository's ID or name",
                        "required": true,
                        "schema": { "$ref": "#/components/schemas/NameOrSnowflake" }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Successful response",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/RepositoryResponse" } }
                        }
                    },
                    "400": {
                        "description": "Unable to decode given path parameter",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "403": {
                        "description": "You are not allowed to patch this resource",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "404": {
                        "description": "Entity was not found",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "406": {
                        "description": "Received an invalid `Name`",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    }
                }
            }
        },
        "/users": {
            "get": {
                "tags": ["Users"],
                "description": "Generic entrypoint route for the Users API.",
                "operationId": "users",
                "responses": {
                    "200": {
                        "description": "Successful response",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/EntrypointResponse" } }
                        }
                    }
                }
            },
            "put": {
                "tags": ["Users"],
                "description": "Creates a new user if the server allows registrations.",
                "operationId": "create_user",
                "responses": {
                    "200": {
                        "description": "Successful response",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/UserResponse" } }
                        }
                    },
                    "403": {
                        "description": "Whether if this server doesn't allow registrations",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "406": {
                        "description": "If the `username` or `email` was taken.",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    }
                }
            },
            "delete": {
                "tags": ["Users"],
                "description": "Delete your user and the data attached to you from the service",
                "operationId": "delete_self",
                "responses": {
                    "201": {
                        "description": "Successful response",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/EmptyApiResponse" } }
                        }
                    },
                    "401": {
                        "description": "If the session couldn't be validated",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "403": {
                        "description": "(Bearer token only) - if the JWT was invalid or expired",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    }
                }
            },
            "patch": {
                "tags": ["Users"],
                "description": "Patch the current authenticated user's metadata about themselves.",
                "operationId": "patch",
                "responses": {
                    "204": {
                        "description": "Successful response",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/EmptyApiResponse" } }
                        }
                    },
                    "400": {
                        "description": "If the request body was invalid (i.e, validation errors)",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "401": {
                        "description": "If the session couldn't be validated",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "403": {
                        "description": "(Bearer token only) - if the JWT was invalid.",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "406": {
                        "description": "If the request body contained invalid data, or if the session header contained invalid data",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    }
                }
            }
        },
        "/users/@me": {
            "get": {
                "tags": ["Users"],
                "description": "Returns a [User] from an authenticated request.",
                "operationId": "get_self",
                "responses": {
                    "200": {
                        "description": "Returns the authenticated user",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/UserResponse" } }
                        }
                    },
                    "400": {
                        "description": "If the request body was invalid (i.e, validation errors)",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "401": {
                        "description": "If the session couldn't be validated",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "403": {
                        "description": "(Bearer token only) - if the JWT was invalid.",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "406": {
                        "description": "If the request body contained invalid data, or if the session header contained invalid data",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    }
                }
            }
        },
        "/users/@me/avatar": {
            "get": {
                "tags": ["Users", "Avatars"],
                "description": "Returns the current authenticated user's current avatar. Use the [`GET /users/@me/avatar/{hash}.png`] REST handler\n to grab by a specific hash.\n\n [`GET /users/@me/avatar/{hash}.png`]: https://charts.noelware.org/docs/server/latest/api/reference/users#GET-/users/@me/avatar/{hash}.png",
                "operationId": "get_self_user_avatar",
                "responses": {
                    "200": {
                        "description": "Successful response",
                        "content": { "image/*": { "schema": { "type": "string", "format": "binary" } } }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    }
                }
            },
            "post": {
                "tags": ["Users", "Avatars"],
                "description": "Uploads a user avatar.",
                "operationId": "upload_avatar",
                "responses": {
                    "201": {
                        "description": "Successful response",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/EmptyApiResponse" } }
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "406": {
                        "description": "Not Acceptable",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    }
                }
            }
        },
        "/users/@me/avatar/{hash}": {
            "get": {
                "tags": ["Users", "Avatars"],
                "description": "Returns the current authenticated user's current avatar by the specific hash",
                "operationId": "get_self_user_avatar_by_hash",
                "parameters": [
                    {
                        "name": "hash",
                        "in": "path",
                        "description": "avatar hash to look up for",
                        "required": true,
                        "schema": { "type": "string" }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Successful response",
                        "content": { "image/*": { "schema": { "type": "string", "format": "binary" } } }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    }
                }
            }
        },
        "/users/@me/repositories": {
            "put": {
                "tags": ["Repositories"],
                "description": "Create a repository with the current authenticated user as the owner of the repository",
                "operationId": "create_user_repository",
                "responses": {
                    "201": {
                        "description": "Repository created",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/RepositoryResponse" } }
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "409": {
                        "description": "Conflict: repository with that name already exists on the user's account",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    }
                }
            }
        },
        "/users/{idOrName}": {
            "get": {
                "tags": ["Users"],
                "description": "Retrieve a user by their ID or username.",
                "operationId": "get_user",
                "parameters": [
                    {
                        "name": "idOrName",
                        "in": "path",
                        "description": "Path parameter that can take a [`Name`] or [`Snowflake`] identifier.",
                        "required": true,
                        "schema": { "$ref": "#/components/schemas/NameOrSnowflake" }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Successful response",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/UserResponse" } }
                        }
                    },
                    "400": {
                        "description": "Invalid `idOrName` specified",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "404": {
                        "description": "Unknown User",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    }
                }
            }
        },
        "/users/{idOrName}/avatar": {
            "get": {
                "tags": ["Users", "Avatars"],
                "description": "Returns the user's current avatar. Use the [`GET /users/{idOrName}/avatar/{hash}.png`] REST route\n to grab an user avatar by a specific hash.\n\n [`GET /users/{idOrName}/avatar/{hash}.png`]: https://charts.noelware.org/docs/server/latest/api/reference/users#GET-/users/{idOrName}/avatar/{hash}.png",
                "operationId": "get_current_user_avatar",
                "parameters": [
                    {
                        "name": "idOrName",
                        "in": "path",
                        "description": "Path parameter that can take a `Name` or Snowflake ID",
                        "required": true,
                        "schema": { "$ref": "#/components/schemas/NameOrSnowflake" }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Successful response",
                        "content": { "image/*": { "schema": { "type": "string", "format": "binary" } } }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    }
                }
            }
        },
        "/users/{idOrName}/avatar/{hash}": {
            "get": {
                "tags": ["Users", "Avatars"],
                "description": "Return a user avatar by the avatar hash.",
                "operationId": "get_user_avatar_by_hash",
                "parameters": [
                    {
                        "name": "hash",
                        "in": "path",
                        "description": "the hash to lookup for",
                        "required": true,
                        "schema": { "type": "string" }
                    },
                    {
                        "name": "idOrName",
                        "in": "path",
                        "description": "Path parameter that can take a `Name` or Snowflake ID",
                        "required": true,
                        "schema": { "$ref": "#/components/schemas/NameOrSnowflake" }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Successful response",
                        "content": { "image/*": { "schema": { "type": "string", "format": "binary" } } }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    }
                }
            }
        },
        "/users/{idOrName}/repositories": {
            "get": {
                "tags": ["Users", "Repositories"],
                "description": "Retrieve all of a user's repositories. This filters out private ones.",
                "operationId": "list_user_repositories",
                "parameters": [
                    {
                        "name": "cursor",
                        "in": "query",
                        "description": "Cursor to passthrough to proceed into the next or previous page.",
                        "required": false,
                        "schema": {
                            "type": "integer",
                            "format": "int64",
                            "description": "Unique identifier for a resource. Based off the [Twitter Snowflake](https://blog.twitter.com/engineering/en_us/a/2010/announcing-snowflake) spec.",
                            "minLength": 15
                        }
                    },
                    {
                        "name": "idOrName",
                        "in": "path",
                        "description": "Path parameter that can take a [`Name`] or [`Snowflake`] identifier.",
                        "required": true,
                        "schema": { "$ref": "#/components/schemas/NameOrSnowflake" }
                    },
                    {
                        "name": "order",
                        "in": "query",
                        "description": "Order to sort the entries by.",
                        "required": false,
                        "schema": { "$ref": "#/components/schemas/OrderBy" }
                    },
                    {
                        "name": "per_page",
                        "in": "query",
                        "description": "How many elements should be present in a page.",
                        "required": false,
                        "schema": { "type": "integer", "format": "int32" }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "List of all the user's repositories",
                        "content": {
                            "application/json": {
                                "schema": { "$ref": "#/components/responses/RepositoryPaginatedResponse" }
                            }
                        }
                    }
                }
            }
        },
        "/v1": {
            "get": {
                "tags": ["Main"],
                "description": "Main entrypoint to charted-server. This is just a generic \"hello world\" response.",
                "operationId": "main",
                "responses": {
                    "200": {
                        "description": "Successful response",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/MainResponse" } }
                        }
                    }
                }
            }
        },
        "/v1/apikeys": {
            "get": {
                "tags": ["API Keys"],
                "description": "Entrypoint for the API Keys API",
                "operationId": "apikeys",
                "responses": {
                    "200": {
                        "description": "Successful response",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/EntrypointResponse" } }
                        }
                    }
                }
            }
        },
        "/v1/apikeys/all": {
            "get": {
                "tags": ["API Keys"],
                "description": "Paginate through all API keys available",
                "operationId": "list_all_apikeys",
                "responses": {
                    "200": {
                        "description": "Successful response",
                        "content": {
                            "application/json": {
                                "schema": { "$ref": "#/components/responses/ApiKeyPaginatedResponse" }
                            }
                        }
                    },
                    "400": {
                        "description": "Unable to process request query parameters",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "401": {
                        "description": "Unauthorized to process the given session details or if the JWT token had expired",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "403": {
                        "description": "Received an invalid password from the `Basic` authorization scheme",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "406": {
                        "description": "Unable to process the session due to some unexpected outcome",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    }
                }
            }
        },
        "/v1/apikeys/{idOrName}": {},
        "/v1/features": {
            "get": {
                "tags": ["Main"],
                "description": "Retrieve this server's features. This is only for enabling or disabling features for API consumers.",
                "operationId": "features",
                "responses": {
                    "200": {
                        "description": "Successful response",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/FeaturesResponse" } }
                        }
                    }
                }
            }
        },
        "/v1/heartbeat": {
            "get": {
                "tags": ["Main"],
                "description": "Generic healthcheck endpoint",
                "operationId": "heartbeat",
                "responses": {
                    "200": {
                        "description": "Successful response",
                        "content": { "text/plain": { "schema": { "type": "string" } } }
                    }
                }
            }
        },
        "/v1/index/{idOrName}": {
            "get": {
                "tags": ["Main", "Users", "Organizations"],
                "description": "Returns a index of a user or organization's Helm charts",
                "operationId": "get_chart_index",
                "parameters": [
                    {
                        "name": "idOrName",
                        "in": "path",
                        "description": "Path parameter that can take a `Name` or `Snowflake` identifier",
                        "required": true,
                        "schema": { "$ref": "#/components/schemas/NameOrSnowflake" }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Chart index for a specific user or organization",
                        "content": {
                            "text/yaml": { "schema": { "$ref": "#/components/responses/ChartIndexResponse" } }
                        }
                    },
                    "404": {
                        "description": "User or Organization was not found",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    }
                }
            }
        },
        "/v1/info": {
            "get": {
                "tags": ["Main"],
                "description": "REST handler for getting more information about this instance that can be visible for API consumers.",
                "operationId": "info",
                "responses": {
                    "200": {
                        "description": "Successful response",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/InfoResponse" } }
                        }
                    }
                }
            }
        },
        "/v1/organizations": {
            "get": {
                "tags": ["Organizations"],
                "description": "Entrypoint for the Organizations API",
                "operationId": "repositories",
                "responses": {
                    "200": {
                        "description": "Successful response",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/EntrypointResponse" } }
                        }
                    }
                }
            }
        },
        "/v1/organizations/{idOrName}": {
            "get": {
                "tags": ["Organizations"],
                "description": "Finds an organization by its ID or name.",
                "operationId": "get_org_by_id_or_name",
                "parameters": [
                    {
                        "name": "idOrName",
                        "in": "path",
                        "description": "Path parameter that can take a `Name` or Snowflake ID",
                        "required": true,
                        "schema": { "$ref": "#/components/schemas/NameOrSnowflake" }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Successful response",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/OrganizationResponse" } }
                        }
                    },
                    "403": {
                        "description": "You are not allowed to see this resource",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "404": {
                        "description": "Entity was not found",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    }
                }
            }
        },
        "/v1/organizations/{idOrName}/icon": {
            "get": {
                "tags": ["Organizations", "Icons"],
                "description": "Returns the organization's current icon. Use the [`GET /organizations/{idOrName}/icons/{hash}.png`] REST route\n to grab an organization icon by a specific hash.\n\n [`GET /organizations/{idOrName}/icons/{hash}.png`]: https://charts.noelware.org/docs/server/latest/api/reference/organizations#GET-/organizations/{idOrName}/icon/{hash}.png",
                "operationId": "get_current_org_icon",
                "parameters": [
                    {
                        "name": "idOrName",
                        "in": "path",
                        "description": "Path parameter that can take a `Name` or Snowflake ID",
                        "required": true,
                        "schema": { "$ref": "#/components/schemas/NameOrSnowflake" }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Successful response",
                        "content": { "image/*": { "schema": { "type": "string", "format": "binary" } } }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    }
                }
            }
        },
        "/v1/organizations/{idOrName}/icon/{hash}": {
            "get": {
                "tags": ["Organizations", "Icons"],
                "description": "Return a organization icon by the icon hash.",
                "operationId": "get_org_icon_by_hash",
                "parameters": [
                    {
                        "name": "hash",
                        "in": "path",
                        "description": "the hash to lookup for",
                        "required": true,
                        "schema": { "type": "string" }
                    },
                    {
                        "name": "idOrName",
                        "in": "path",
                        "description": "Path parameter that can take a `Name` or Snowflake ID",
                        "required": true,
                        "schema": { "$ref": "#/components/schemas/NameOrSnowflake" }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Successful response",
                        "content": { "image/*": { "schema": { "type": "string", "format": "binary" } } }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    }
                }
            }
        },
        "/v1/organizations/{idOrName}/repositories": {
            "get": {
                "tags": ["Organizations", "Repositories"],
                "description": "Retrieve all of a organization's repositories. This filters out private ones.",
                "operationId": "list_org_repositories",
                "parameters": [
                    {
                        "name": "cursor",
                        "in": "query",
                        "description": "Cursor to passthrough to proceed into the next or previous page.",
                        "required": false,
                        "schema": {
                            "type": "integer",
                            "format": "int64",
                            "description": "Unique identifier for a resource. Based off the [Twitter Snowflake](https://blog.twitter.com/engineering/en_us/a/2010/announcing-snowflake) spec.",
                            "minLength": 15
                        }
                    },
                    {
                        "name": "idOrName",
                        "in": "path",
                        "description": "Path parameter that can take a [`Name`] or [`Snowflake`] identifier.",
                        "required": true,
                        "schema": { "$ref": "#/components/schemas/NameOrSnowflake" }
                    },
                    {
                        "name": "order",
                        "in": "query",
                        "description": "Order to sort the entries by.",
                        "required": false,
                        "schema": { "$ref": "#/components/schemas/OrderBy" }
                    },
                    {
                        "name": "per_page",
                        "in": "query",
                        "description": "How many elements should be present in a page.",
                        "required": false,
                        "schema": { "type": "integer", "format": "int32" }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "List of all the organization's repositories",
                        "content": {
                            "application/json": {
                                "schema": { "$ref": "#/components/responses/RepositoryPaginatedResponse" }
                            }
                        }
                    }
                }
            }
        },
        "/v1/repositories": {
            "get": {
                "tags": ["Repositories"],
                "description": "Entrypoint for the Repositories API",
                "operationId": "repositories",
                "responses": {
                    "200": {
                        "description": "Successful response",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/EntrypointResponse" } }
                        }
                    }
                }
            }
        },
        "/v1/repositories/{id}": {
            "get": {
                "tags": ["Repositories"],
                "description": "Finds a repository by its ID.",
                "operationId": "get_repo_by_id",
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "required": true,
                        "schema": {
                            "type": "integer",
                            "format": "int64",
                            "description": "Unique identifier for a resource. Based off the [Twitter Snowflake](https://blog.twitter.com/engineering/en_us/a/2010/announcing-snowflake) spec.",
                            "minLength": 15
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Successful response",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/RepositoryResponse" } }
                        }
                    },
                    "403": {
                        "description": "You are not allowed to see this resource",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "404": {
                        "description": "Entity was not found",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    }
                }
            }
        },
        "/v1/repositories/{owner}/{name}": {
            "get": {
                "tags": ["Repositories"],
                "description": "Find a repository by the owner's ID/name and the repository's ID/name\n\n ## Examples\n ```http\n # Acceptable\n GET /repositories/charted/server\n\n # Not acceptable\n GET /repositories/server  # `server` will be treated as a owner's ID or name.\n GET /repositories/charted # use /[users|organizations]/repositories to list all repositories\n ```",
                "operationId": "get_repo_by_owner_and_name",
                "parameters": [
                    {
                        "name": "owner",
                        "in": "path",
                        "description": "owner's ID or name",
                        "required": true,
                        "schema": { "$ref": "#/components/schemas/NameOrSnowflake" }
                    },
                    {
                        "name": "repo",
                        "in": "path",
                        "description": "repository's ID or name",
                        "required": true,
                        "schema": { "$ref": "#/components/schemas/NameOrSnowflake" }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Successful response",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/RepositoryResponse" } }
                        }
                    },
                    "400": {
                        "description": "Unable to decode given path parameter",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "403": {
                        "description": "You are not allowed to patch this resource",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "404": {
                        "description": "Entity was not found",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "406": {
                        "description": "Received an invalid `Name`",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    }
                }
            }
        },
        "/v1/users": {
            "get": {
                "tags": ["Users"],
                "description": "Generic entrypoint route for the Users API.",
                "operationId": "users",
                "responses": {
                    "200": {
                        "description": "Successful response",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/EntrypointResponse" } }
                        }
                    }
                }
            },
            "put": {
                "tags": ["Users"],
                "description": "Creates a new user if the server allows registrations.",
                "operationId": "create_user",
                "responses": {
                    "200": {
                        "description": "Successful response",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/UserResponse" } }
                        }
                    },
                    "403": {
                        "description": "Whether if this server doesn't allow registrations",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "406": {
                        "description": "If the `username` or `email` was taken.",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    }
                }
            },
            "delete": {
                "tags": ["Users"],
                "description": "Delete your user and the data attached to you from the service",
                "operationId": "delete_self",
                "responses": {
                    "201": {
                        "description": "Successful response",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/EmptyApiResponse" } }
                        }
                    },
                    "401": {
                        "description": "If the session couldn't be validated",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "403": {
                        "description": "(Bearer token only) - if the JWT was invalid or expired",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    }
                }
            },
            "patch": {
                "tags": ["Users"],
                "description": "Patch the current authenticated user's metadata about themselves.",
                "operationId": "patch",
                "responses": {
                    "204": {
                        "description": "Successful response",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/EmptyApiResponse" } }
                        }
                    },
                    "400": {
                        "description": "If the request body was invalid (i.e, validation errors)",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "401": {
                        "description": "If the session couldn't be validated",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "403": {
                        "description": "(Bearer token only) - if the JWT was invalid.",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "406": {
                        "description": "If the request body contained invalid data, or if the session header contained invalid data",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    }
                }
            }
        },
        "/v1/users/@me": {
            "get": {
                "tags": ["Users"],
                "description": "Returns a [User] from an authenticated request.",
                "operationId": "get_self",
                "responses": {
                    "200": {
                        "description": "Returns the authenticated user",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/UserResponse" } }
                        }
                    },
                    "400": {
                        "description": "If the request body was invalid (i.e, validation errors)",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "401": {
                        "description": "If the session couldn't be validated",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "403": {
                        "description": "(Bearer token only) - if the JWT was invalid.",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "406": {
                        "description": "If the request body contained invalid data, or if the session header contained invalid data",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    }
                }
            }
        },
        "/v1/users/@me/avatar": {
            "get": {
                "tags": ["Users", "Avatars"],
                "description": "Returns the current authenticated user's current avatar. Use the [`GET /users/@me/avatar/{hash}.png`] REST handler\n to grab by a specific hash.\n\n [`GET /users/@me/avatar/{hash}.png`]: https://charts.noelware.org/docs/server/latest/api/reference/users#GET-/users/@me/avatar/{hash}.png",
                "operationId": "get_self_user_avatar",
                "responses": {
                    "200": {
                        "description": "Successful response",
                        "content": { "image/*": { "schema": { "type": "string", "format": "binary" } } }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    }
                }
            },
            "post": {
                "tags": ["Users", "Avatars"],
                "description": "Uploads a user avatar.",
                "operationId": "upload_avatar",
                "responses": {
                    "201": {
                        "description": "Successful response",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/EmptyApiResponse" } }
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "406": {
                        "description": "Not Acceptable",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    }
                }
            }
        },
        "/v1/users/@me/avatar/{hash}": {
            "get": {
                "tags": ["Users", "Avatars"],
                "description": "Returns the current authenticated user's current avatar by the specific hash",
                "operationId": "get_self_user_avatar_by_hash",
                "parameters": [
                    {
                        "name": "hash",
                        "in": "path",
                        "description": "avatar hash to look up for",
                        "required": true,
                        "schema": { "type": "string" }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Successful response",
                        "content": { "image/*": { "schema": { "type": "string", "format": "binary" } } }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    }
                }
            }
        },
        "/v1/users/@me/repositories": {
            "put": {
                "tags": ["Repositories"],
                "description": "Create a repository with the current authenticated user as the owner of the repository",
                "operationId": "create_user_repository",
                "responses": {
                    "201": {
                        "description": "Repository created",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/RepositoryResponse" } }
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "409": {
                        "description": "Conflict: repository with that name already exists on the user's account",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    }
                }
            }
        },
        "/v1/users/{idOrName}": {
            "get": {
                "tags": ["Users"],
                "description": "Retrieve a user by their ID or username.",
                "operationId": "get_user",
                "parameters": [
                    {
                        "name": "idOrName",
                        "in": "path",
                        "description": "Path parameter that can take a [`Name`] or [`Snowflake`] identifier.",
                        "required": true,
                        "schema": { "$ref": "#/components/schemas/NameOrSnowflake" }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Successful response",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/UserResponse" } }
                        }
                    },
                    "400": {
                        "description": "Invalid `idOrName` specified",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    },
                    "404": {
                        "description": "Unknown User",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    }
                }
            }
        },
        "/v1/users/{idOrName}/avatar": {
            "get": {
                "tags": ["Users", "Avatars"],
                "description": "Returns the user's current avatar. Use the [`GET /users/{idOrName}/avatar/{hash}.png`] REST route\n to grab an user avatar by a specific hash.\n\n [`GET /users/{idOrName}/avatar/{hash}.png`]: https://charts.noelware.org/docs/server/latest/api/reference/users#GET-/users/{idOrName}/avatar/{hash}.png",
                "operationId": "get_current_user_avatar",
                "parameters": [
                    {
                        "name": "idOrName",
                        "in": "path",
                        "description": "Path parameter that can take a `Name` or Snowflake ID",
                        "required": true,
                        "schema": { "$ref": "#/components/schemas/NameOrSnowflake" }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Successful response",
                        "content": { "image/*": { "schema": { "type": "string", "format": "binary" } } }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    }
                }
            }
        },
        "/v1/users/{idOrName}/avatar/{hash}": {
            "get": {
                "tags": ["Users", "Avatars"],
                "description": "Return a user avatar by the avatar hash.",
                "operationId": "get_user_avatar_by_hash",
                "parameters": [
                    {
                        "name": "hash",
                        "in": "path",
                        "description": "the hash to lookup for",
                        "required": true,
                        "schema": { "type": "string" }
                    },
                    {
                        "name": "idOrName",
                        "in": "path",
                        "description": "Path parameter that can take a `Name` or Snowflake ID",
                        "required": true,
                        "schema": { "$ref": "#/components/schemas/NameOrSnowflake" }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Successful response",
                        "content": { "image/*": { "schema": { "type": "string", "format": "binary" } } }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "content": {
                            "application/json": { "schema": { "$ref": "#/components/responses/ApiErrorResponse" } }
                        }
                    }
                }
            }
        },
        "/v1/users/{idOrName}/repositories": {
            "get": {
                "tags": ["Users", "Repositories"],
                "description": "Retrieve all of a user's repositories. This filters out private ones.",
                "operationId": "list_user_repositories",
                "parameters": [
                    {
                        "name": "cursor",
                        "in": "query",
                        "description": "Cursor to passthrough to proceed into the next or previous page.",
                        "required": false,
                        "schema": {
                            "type": "integer",
                            "format": "int64",
                            "description": "Unique identifier for a resource. Based off the [Twitter Snowflake](https://blog.twitter.com/engineering/en_us/a/2010/announcing-snowflake) spec.",
                            "minLength": 15
                        }
                    },
                    {
                        "name": "idOrName",
                        "in": "path",
                        "description": "Path parameter that can take a [`Name`] or [`Snowflake`] identifier.",
                        "required": true,
                        "schema": { "$ref": "#/components/schemas/NameOrSnowflake" }
                    },
                    {
                        "name": "order",
                        "in": "query",
                        "description": "Order to sort the entries by.",
                        "required": false,
                        "schema": { "$ref": "#/components/schemas/OrderBy" }
                    },
                    {
                        "name": "per_page",
                        "in": "query",
                        "description": "How many elements should be present in a page.",
                        "required": false,
                        "schema": { "type": "integer", "format": "int32" }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "List of all the user's repositories",
                        "content": {
                            "application/json": {
                                "schema": { "$ref": "#/components/responses/RepositoryPaginatedResponse" }
                            }
                        }
                    }
                }
            }
        }
    },
    "components": {
        "schemas": {
            "ApiKey": {
                "type": "object",
                "description": "A resource for personal-managed API tokens that is created by a User. This is useful\nfor command line tools or scripts that need to interact with charted-server, but\nthe main use-case is for the [Helm plugin](https://charts.noelware.org/docs/helm-plugin/current).",
                "required": ["created_at", "updated_at", "scopes", "name", "id"],
                "properties": {
                    "created_at": { "$ref": "#/components/schemas/DateTime" },
                    "description": {
                        "type": "string",
                        "description": "Short description about this API key.",
                        "nullable": true
                    },
                    "expires_in": { "allOf": [{ "$ref": "#/components/schemas/DateTime" }], "nullable": true },
                    "id": {
                        "type": "integer",
                        "format": "int64",
                        "description": "Unique identifier for a resource. Based off the [Twitter Snowflake](https://blog.twitter.com/engineering/en_us/a/2010/announcing-snowflake) spec.",
                        "minLength": 15
                    },
                    "name": {
                        "type": "string",
                        "description": "A valid UTF-8 string that is used to identify a resource from the REST API in a humane fashion. This is meant to help identify a resource without trying to calculate the resource's Snowflake on the first try.",
                        "maxLength": 32,
                        "minLength": 1,
                        "pattern": "([A-z]|-|_|\\d{0,9}){1,32}"
                    },
                    "scopes": {
                        "type": "integer",
                        "format": "int64",
                        "description": "The scopes that are attached to this API key resource."
                    },
                    "token": {
                        "type": "string",
                        "description": "The token itself. This is never revealed when querying, but only revealed\nwhen you create the token.",
                        "nullable": true
                    },
                    "updated_at": { "$ref": "#/components/schemas/DateTime" }
                }
            },
            "ApiKeyScope": {
                "oneOf": [
                    {
                        "type": "number",
                        "format": "int64",
                        "description": "Represents a scope that is represented as an unsigned 64-bit integer, each scope can be in the range of 1..4503599627370496",
                        "maximum": 4503599627370496,
                        "minimum": 1
                    },
                    {
                        "type": "string",
                        "description": "represents a named version of a scope which is represented as 'entity:operation', i.e, `apikey:list` will allow you to list all API keys",
                        "enum": [
                            "user:access",
                            "user:update",
                            "user:delete",
                            "user:connections",
                            "user:notifications",
                            "user:avatar:update",
                            "user:sessions:list",
                            "repo:access",
                            "repo:create",
                            "repo:delete",
                            "repo:update",
                            "repo:write",
                            "repo:icon:update",
                            "repo:releases:create",
                            "repo:releases:update",
                            "repo:releases:delete",
                            "repo:members:list",
                            "repo:members:update",
                            "repo:members:kick",
                            "repo:members:invites:access",
                            "repo:members:invites:update",
                            "repo:members:invites:delete",
                            "repo:webhooks:list",
                            "repo:webhooks:create",
                            "repo:webhooks:update",
                            "repo:webhooks:delete",
                            "repo:webhooks:events:access",
                            "repo:webhooks:events:delete",
                            "apikeys:view",
                            "apikeys:list",
                            "apikeys:create",
                            "apikeys:delete",
                            "apikeys:update",
                            "org:access",
                            "org:create",
                            "org:update",
                            "org:delete",
                            "org:members:invites",
                            "org:members:list",
                            "org:members:kick",
                            "org:members:update",
                            "org:webhooks:list",
                            "org:webhooks:create",
                            "org:webhooks:update",
                            "org:webhooks:delete",
                            "org:webhooks:events:list",
                            "org:webhooks:events:delete",
                            "admin:stats",
                            "admin:users:create",
                            "admin:users:delete",
                            "admin:users:update",
                            "admin:orgs:delete",
                            "admin:orgs:update"
                        ]
                    }
                ],
                "description": "Represents what a single API key scope can represent, this will always represent unsigned 64-bit integers in the API server itself"
            },
            "Chart": {
                "type": "object",
                "description": "Represents the skeleton of a `Chart.yaml` file.",
                "required": ["apiVersion", "name", "version"],
                "properties": {
                    "annotations": {
                        "type": "object",
                        "description": "Mapping of custom metadata that can be used for custom attributes.\n\n### standardized for charted-server\n* `charts.noelware.org/maintainers` ~ a comma-delimited list of all the maintainers\nthat are mapped by their `Name` or snowflake ID",
                        "additionalProperties": { "type": "string" }
                    },
                    "apiVersion": { "$ref": "#/components/schemas/ChartSpecVersion" },
                    "appVersion": {
                        "type": "string",
                        "description": "Note that the appVersion field is not related to the version field. It is a way of specifying the version of the\napplication. For example, the drupal chart may have an appVersion: \"8.2.1\", indicating that the version of Drupal\nincluded in the chart (by default) is 8.2.1. This field is informational, and has no impact on chart version calculations.\n\nWrapping the version in quotes is highly recommended. It forces the YAML parser to treat the version number as a string.\nLeaving it unquoted can lead to parsing issues in some cases. For example, YAML interprets 1.0 as a floating point value,\nand a git commit SHA like 1234e10 as scientific notation.",
                        "nullable": true
                    },
                    "dependencies": {
                        "type": "array",
                        "items": { "$ref": "#/components/schemas/ChartDependency" },
                        "description": "In Helm, one chart may depend on any number of other charts. These dependencies can be dynamically linked using the dependencies'\nfield in Chart.yaml or brought in to the charts/ directory and managed manually. The charts required by the current chart are defined as a list\nin the dependencies field."
                    },
                    "deprecated": {
                        "type": "boolean",
                        "description": "When managing charts in a Chart Repository, it is sometimes necessary to deprecate a chart. The optional deprecated field\nin Chart.yaml can be used to mark a chart as deprecated. If the latest version of a chart in the repository is marked\nas deprecated, then the chart as a whole is considered to be deprecated.\n\nThe chart name can be later reused by publishing a newer version that is not marked as deprecated."
                    },
                    "description": {
                        "type": "string",
                        "description": "A single-sentence description of this project",
                        "nullable": true
                    },
                    "home": {
                        "type": "string",
                        "description": "The URL of this project's homepage.",
                        "nullable": true
                    },
                    "icon": {
                        "type": "string",
                        "description": "A URL or an SVG or PNG image to be used as an icon",
                        "nullable": true
                    },
                    "keywords": {
                        "type": "array",
                        "items": { "type": "string" },
                        "description": "A list of keywords about this project. These keywords can be searched\nvia the /search endpoint if it's enabled."
                    },
                    "kubeVersion": { "allOf": [{ "$ref": "#/components/schemas/VersionReq" }], "nullable": true },
                    "maintainers": {
                        "type": "array",
                        "items": { "$ref": "#/components/schemas/ChartMaintainer" },
                        "description": "A list of name and URL/email address combinations for the maintainer(s)"
                    },
                    "name": { "type": "string", "description": "The name of the chart." },
                    "sources": {
                        "type": "array",
                        "items": { "type": "string" },
                        "description": "A list of URLs to the source code for this project"
                    },
                    "type": { "$ref": "#/components/schemas/ChartType" },
                    "version": { "$ref": "#/components/schemas/Version" }
                }
            },
            "ChartDependency": {
                "type": "object",
                "description": "In Helm, one chart may depend on any number of other charts. These dependencies can be dynamically linked using the dependencies'\nfield in Chart.yaml or brought in to the charts/ directory and managed manually. The charts required by the current chart are defined\nas a list in the dependencies field.",
                "required": ["name"],
                "properties": {
                    "alias": {
                        "type": "string",
                        "description": "Alias that is used to identify a chart. Useful for pointing to the\nsame chart multiple times",
                        "nullable": true
                    },
                    "condition": {
                        "type": "string",
                        "description": "YAML path that resolves to a boolean to enable or disable charts\ndynamically.",
                        "nullable": true
                    },
                    "import-values": {
                        "type": "array",
                        "items": { "$ref": "#/components/schemas/StringOrImportValue" },
                        "description": "[`ImportValues`][ImportValue] holds the mapping of source values to parent key to be imported.\nEach item can be a string or pair of child/parent sublist items."
                    },
                    "name": { "type": "string", "description": "The name of the chart" },
                    "repository": {
                        "type": "string",
                        "description": "Repository URL or alias that should be used to grab\nthe dependency from.",
                        "nullable": true
                    },
                    "tags": {
                        "type": "array",
                        "items": { "type": "string" },
                        "description": "List of tags that can be used to group charts to enable/disable together."
                    },
                    "version": { "allOf": [{ "$ref": "#/components/schemas/Version" }], "nullable": true }
                }
            },
            "ChartIndex": {
                "type": "object",
                "description": "Schema skeleton for a `index.yml` file that represents a Chart index.",
                "required": ["api_version", "generated_at"],
                "properties": {
                    "api_version": {
                        "type": "string",
                        "description": "API version for the `index.yaml` file. Will be a constant as `v1`."
                    },
                    "entries": {
                        "type": "object",
                        "description": "List of all possible entries for this user/organization.",
                        "additionalProperties": {
                            "type": "array",
                            "items": { "$ref": "#/components/schemas/ChartIndexSpec" },
                            "description": "Index contents of a repository",
                            "uniqueItems": true
                        }
                    },
                    "generated_at": {
                        "type": "string",
                        "format": "date-time",
                        "description": "DateTime of when this `index.yaml` was last generated. In charted-server, this is relative on when a new chart release was last published."
                    }
                }
            },
            "ChartIndexSpec": {
                "allOf": [
                    { "$ref": "#/components/schemas/Chart" },
                    {
                        "type": "object",
                        "properties": {
                            "created": { "allOf": [{ "$ref": "#/components/schemas/DateTime" }], "nullable": true },
                            "digest": { "type": "string", "nullable": true },
                            "removed": { "type": "boolean" },
                            "urls": { "type": "array", "items": { "type": "string" } }
                        }
                    }
                ],
                "description": "Represents the specification for a Chart.yaml-schema from a `index.yaml` reference."
            },
            "ChartMaintainer": {
                "type": "object",
                "description": "Name and URL/email address combination as a maintainer. [ChartMaintainer::name] can be referenced\nas a `NameOrSnowflake` union.",
                "required": ["name"],
                "properties": {
                    "email": { "type": "string", "description": "The maintainer's email", "nullable": true },
                    "name": { "type": "string", "description": "The maintainer's name" },
                    "url": { "type": "string", "description": "URL for the maintainer", "nullable": true }
                }
            },
            "ChartSpecVersion": {
                "type": "string",
                "description": "The apiVersion field should be v2 for Helm charts that require at least Helm 3. Charts supporting previous Helm versions have an apiVersion set to v1 and are still installable by Helm 3.",
                "default": "v2",
                "enum": ["v1", "v2"]
            },
            "ChartType": {
                "type": "string",
                "description": "Represents what type this chart is. Do keep in mind that `operator` is not supported by Helm, but is specific to the API server. For serializing to valid Helm objects, `application` will be the replacement.",
                "default": "application",
                "enum": ["application", "library", "operator"]
            },
            "CreateApiKeyPayload": {
                "type": "object",
                "description": "Request body payload for creating a API key.",
                "required": ["name"],
                "properties": {
                    "description": { "type": "string", "description": "Description of the API key", "nullable": true },
                    "expires_in": { "allOf": [{ "$ref": "#/components/schemas/Duration" }], "nullable": true },
                    "name": { "$ref": "#/components/schemas/Name" },
                    "scopes": {
                        "type": "array",
                        "items": { "$ref": "#/components/schemas/ApiKeyScope" },
                        "description": "the list of scopes to apply to this API key"
                    }
                }
            },
            "CreateOrganizationPayload": {
                "type": "object",
                "description": "Request body payload for creating a new organization",
                "required": ["name"],
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Short description about this organization. If `description` was set to `null`, then\nthis will not be updated, if `description` was a empty string, the `description`\nwill be set to a empty string and will present as \"*no description for this organization*\"\nin Hoshi.",
                        "nullable": true
                    },
                    "display_name": {
                        "type": "string",
                        "description": "Display name for this organization.",
                        "nullable": true
                    },
                    "name": { "$ref": "#/components/schemas/Name" },
                    "private": { "type": "boolean", "description": "Whether if the organization is private or not." }
                }
            },
            "CreateRepositoryPayload": {
                "type": "object",
                "description": "Payload to create a Repository entity.",
                "required": ["name"],
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Short description about this repository.",
                        "nullable": true
                    },
                    "name": { "$ref": "#/components/schemas/Name" },
                    "private": { "type": "boolean", "description": "Whether if this repository is private." },
                    "readme": {
                        "type": "string",
                        "description": "The contents of the README that will be displayed on the repository. If you're\nusing charted's official Helm plugin, new releases can update its README and it'll\nbe reflected.\n\nThis should be valid Markdown, but XSS cross scripting is impossible as scripts\nin codeblocks or via `<script>` won't be executed.\n\nYou can retrieve a repository's README (if it is public or if you have access) with\nthe [`GET /cdn`](https://charts.noelware.org/docs/server/latest/api/cdn#GET-{...params}) REST\nendpoint if the instance has the CDN feature enabled. It'll be under `/repositories/{id}/README.md`.",
                        "nullable": true
                    },
                    "type": { "$ref": "#/components/schemas/ChartType" }
                }
            },
            "CreateUserPayload": {
                "type": "object",
                "description": "Represents the payload for creating a new user.",
                "required": ["username", "password", "email"],
                "properties": {
                    "email": { "type": "string", "description": "Email address to identify this user" },
                    "password": { "$ref": "#/components/schemas/password" },
                    "username": { "$ref": "#/components/schemas/Name" }
                }
            },
            "DateTime": {
                "type": "string",
                "format": "date-time",
                "description": "RFC3339-encoded string that represents a datetime",
                "readOnly": true
            },
            "EntrypointResponse": {
                "type": "object",
                "description": "Generic entrypoint message for any API routes like `/users`.",
                "required": ["message", "docs"],
                "properties": {
                    "docs": {
                        "type": "string",
                        "description": "URL to the documentation to where you can explore more routes for\nthis specific API."
                    },
                    "message": { "type": "string", "description": "A cute message to greet you with" }
                }
            },
            "Error": {
                "type": "object",
                "description": "Represents an error that could occur.",
                "required": ["code", "message"],
                "properties": {
                    "code": { "$ref": "#/components/schemas/ErrorCode" },
                    "details": {
                        "description": "Other details to send to the user to give even more context about this error.",
                        "nullable": true
                    },
                    "message": {
                        "type": "string",
                        "description": "Humane message that is based off the contextual [error code][Error::code] to give\na brief description."
                    }
                }
            },
            "ErrorCode": {
                "type": "string",
                "description": "Represents a error code that can happen.",
                "enum": [
                    "INTERNAL_SERVER_ERROR",
                    "REACHED_UNEXPECTED_EOF",
                    "UNABLE_TO_PROCESS",
                    "HANDLER_NOT_FOUND",
                    "ENTITY_NOT_FOUND",
                    "ENTITY_ALREADY_EXISTS",
                    "VALIDATION_FAILED",
                    "UNKNOWN_CDN_QUERY",
                    "INVALID_CONTENT_TYPE",
                    "SESSION_ONLY_ROUTE",
                    "INVALID_HTTP_HEADER",
                    "UNABLE_TO_DECODE_BASE64",
                    "INVALID_UTF8",
                    "INVALID_BODY",
                    "MISSING_HEADER",
                    "REGISTRATIONS_DISABLED",
                    "MISSING_PASSWORD",
                    "ACCESS_NOT_PERMITTED",
                    "IO",
                    "INVALID_TYPE",
                    "BAD_REQUEST",
                    "MISSING_CONTENT_TYPE",
                    "WRONG_PARAMETERS",
                    "PARSING_FAILED_IN_PATH_PARAM",
                    "INVALID_JWT_CLAIM",
                    "MISSING_AUTHORIZATION_HEADER",
                    "INVALID_PASSWORD",
                    "INVALID_AUTHENTICATION_TYPE",
                    "INVALID_AUTHORIZATION_PARTS",
                    "INVALID_SESSION_TOKEN",
                    "SESSION_EXPIRED",
                    "UNKNOWN_SESSION",
                    "REFRESH_TOKEN_REQUIRED",
                    "MAX_PER_PAGE_EXCEEDED",
                    "UNABLE_TO_PARSE_PATH_PARAMETER",
                    "MISSING_PATH_PARAMETER",
                    "INVALID_JSON_PAYLOAD",
                    "UNKNOWN_MULTIPART_FIELD",
                    "INCOMPLETE_MULTIPART_FIELD_DATA",
                    "READ_MULTIPART_HEADER_FAILED",
                    "DECODE_MULTIPART_CONTENT_TYPE_FAILED",
                    "MISSING_MULTIPART_BOUNDARY",
                    "NO_MULTIPART_RECEIVED",
                    "INCOMPLETE_MULTIPART_STREAM",
                    "DECODE_MULTIPART_HEADER_NAME_FAILED",
                    "STREAM_SIZE_EXCEEDED",
                    "MULTIPART_FIELDS_SIZE_EXCEEDED",
                    "MULTIPART_STREAM_READ_FAILED",
                    "MISSING_MULTIPART_FIELD",
                    "INVALID_MULTIPART_BOUNDARY"
                ]
            },
            "FeaturesResponse": {
                "type": "object",
                "description": "Represents the response from the `GET /features` REST handler",
                "required": [
                    "docker_registry",
                    "registrations",
                    "audit_logs",
                    "webhooks",
                    "is_invite_only",
                    "integrations",
                    "search",
                    "gc"
                ],
                "properties": {
                    "audit_logs": {
                        "type": "boolean",
                        "description": "Whether if the Audit Logging feature is enabled or not."
                    },
                    "docker_registry": {
                        "type": "boolean",
                        "description": "Whether if the external OCI registry experimental feature or the home-made implementation registry feature is enabled or not."
                    },
                    "gc": {
                        "type": "boolean",
                        "description": "whether if server garbage collection is enabled or not"
                    },
                    "integrations": {
                        "type": "object",
                        "description": "Object of all the session integrations available.",
                        "additionalProperties": { "type": "boolean" }
                    },
                    "is_invite_only": {
                        "type": "boolean",
                        "description": "Whether if this server instance is invite-only.",
                        "deprecated": true
                    },
                    "registrations": {
                        "type": "boolean",
                        "description": "Whether if registrations are enabled on the server"
                    },
                    "search": {
                        "type": "boolean",
                        "description": "Whether if the server has search capabilities with the Elasticsearch or Meilisearch backend"
                    },
                    "webhooks": {
                        "type": "boolean",
                        "description": "Whether if the Webhooks feature is enabled or not."
                    }
                }
            },
            "ImportValue": {
                "type": "object",
                "description": "ImportValues hold the mapping of source values to parent key to be imported. Each\nitem can be a child/parent sublist item or a string.",
                "required": ["parent", "child"],
                "properties": {
                    "child": { "type": "string", "description": "The source key of the values to be imported" },
                    "parent": { "type": "string", "description": "The destination path in the parent chart's values." }
                }
            },
            "InfoResponse": {
                "type": "object",
                "description": "Represents the response for the `GET /info` REST handler.",
                "required": ["distribution", "commit_sha", "build_date", "product", "version", "vendor"],
                "properties": {
                    "build_date": { "type": "string", "description": "Build date in RFC3339 format" },
                    "commit_sha": { "type": "string", "description": "The commit hash from the Git repository." },
                    "distribution": { "$ref": "#/components/schemas/Distribution" },
                    "product": { "type": "string", "description": "Product name. Will always be \"charted-server\"" },
                    "vendor": {
                        "type": "string",
                        "description": "Vendor of charted-server, will always be \"Noelware, LLC.\""
                    },
                    "version": {
                        "type": "string",
                        "description": "Valid SemVer 2 of the current version of this instance"
                    }
                }
            },
            "MainResponse": {
                "type": "object",
                "description": "Response object for the `GET /` REST controller.",
                "required": ["message", "tagline", "docs"],
                "properties": {
                    "docs": {
                        "type": "string",
                        "description": "Documentation URL for this generic entrypoint response."
                    },
                    "message": {
                        "type": "string",
                        "description": "The message, which will always be \"Hello, world!\""
                    },
                    "tagline": { "type": "string", "description": "You know, for Helm charts?" }
                }
            },
            "Member": {
                "type": "object",
                "description": "Represents a resource that is correlated to a repository or organization member\nthat can control the repository's metadata.",
                "required": ["permissions", "updated_at", "joined_at", "user", "id"],
                "properties": {
                    "display_name": {
                        "type": "string",
                        "description": "Display name for this member. This should be formatted as '[{display_name}][Member::display_name] (@[{username}][User::username])' if this\nis set, otherwise '@[{username}][User::username]' is used.",
                        "nullable": true
                    },
                    "id": {
                        "type": "integer",
                        "format": "int64",
                        "description": "Unique identifier for a resource. Based off the [Twitter Snowflake](https://blog.twitter.com/engineering/en_us/a/2010/announcing-snowflake) spec.",
                        "minLength": 15
                    },
                    "joined_at": { "$ref": "#/components/schemas/DateTime" },
                    "permissions": {
                        "type": "integer",
                        "format": "int64",
                        "description": "Bitfield value of this member's permissions.",
                        "minimum": 0
                    },
                    "updated_at": { "$ref": "#/components/schemas/DateTime" },
                    "user": { "$ref": "#/components/schemas/User" }
                }
            },
            "Name": {
                "type": "string",
                "description": "A valid UTF-8 string that is used to identify a resource from the REST API in a humane fashion. This is meant to help identify a resource without trying to calculate the resource's Snowflake on the first try.",
                "maxLength": 32,
                "minLength": 1,
                "pattern": "([A-z]|-|_|\\d{0,9}){1,32}"
            },
            "NameOrSnowflake": {
                "oneOf": [
                    {
                        "type": "integer",
                        "format": "int64",
                        "description": "Unique identifier for a resource. Based off the [Twitter Snowflake](https://blog.twitter.com/engineering/en_us/a/2010/announcing-snowflake) spec.",
                        "minLength": 15
                    },
                    {
                        "type": "string",
                        "description": "A valid UTF-8 string that is used to identify a resource from the REST API in a humane fashion. This is meant to help identify a resource without trying to calculate the resource's Snowflake on the first try.",
                        "maxLength": 32,
                        "minLength": 1,
                        "pattern": "([A-z]|-|_|\\d{0,9}){1,32}"
                    }
                ],
                "description": "Represents a union enum that can hold a Snowflake and a Name, which is a String that is validated with the Name regex."
            },
            "OrderBy": {
                "type": "string",
                "description": "The ordering to use when querying paginated REST calls.",
                "enum": ["ASC", "DESC"]
            },
            "Organization": {
                "type": "object",
                "description": "Represents a unified entity that can manage and own repositories outside\na User. Organizations to the server is used for business-related Helm charts\nthat aren't tied to a specific User.",
                "required": ["created_at", "updated_at", "owner", "name", "id"],
                "properties": {
                    "created_at": { "$ref": "#/components/schemas/DateTime" },
                    "display_name": {
                        "type": "string",
                        "description": "Display name for this organization. It should be formatted as '[{display_name}][Organization::display_name] (@[{name}][Organization::name])'\nor '@[{name}][Organization::name]'.",
                        "nullable": true
                    },
                    "gravatar_email": {
                        "type": "string",
                        "description": "Valid email address that points to a Gravatar avatar, or `null` if it shouldn't use one as the primary avatar",
                        "nullable": true
                    },
                    "icon_hash": {
                        "type": "string",
                        "description": "Unique hash to locate an organization's icon, this also includes the extension that this icon is, i.e, `png`.",
                        "nullable": true
                    },
                    "id": {
                        "type": "integer",
                        "format": "int64",
                        "description": "Unique identifier for a resource. Based off the [Twitter Snowflake](https://blog.twitter.com/engineering/en_us/a/2010/announcing-snowflake) spec.",
                        "minLength": 15
                    },
                    "name": { "$ref": "#/components/schemas/Name" },
                    "owner": {
                        "type": "integer",
                        "format": "int64",
                        "description": "Unique identifier for a resource. Based off the [Twitter Snowflake](https://blog.twitter.com/engineering/en_us/a/2010/announcing-snowflake) spec.",
                        "minLength": 15
                    },
                    "private": {
                        "type": "boolean",
                        "description": "Whether this organization is private and only its member can access this resource."
                    },
                    "twitter_handle": {
                        "type": "string",
                        "description": "Returns the twitter handle for this organization, if populated.",
                        "nullable": true
                    },
                    "updated_at": { "$ref": "#/components/schemas/DateTime" },
                    "verified_publisher": {
                        "type": "boolean",
                        "description": "Whether if this Organization is a Verified Publisher or not."
                    }
                }
            },
            "PageInfo": {
                "type": "object",
                "description": "Information about a [pagination][Pagination] page.",
                "required": ["cursor"],
                "properties": { "cursor": { "$ref": "#/components/schemas/Snowflake" } }
            },
            "PaginatedApiKey": {
                "type": "object",
                "required": ["data", "page_info"],
                "properties": {
                    "data": { "type": "array", "items": { "$ref": "#/components/schemas/ApiKey" } },
                    "page_info": { "$ref": "#/components/schemas/PageInfo" }
                }
            },
            "PaginatedMember": {
                "type": "object",
                "required": ["data", "page_info"],
                "properties": {
                    "data": { "type": "array", "items": { "$ref": "#/components/schemas/Member" } },
                    "page_info": { "$ref": "#/components/schemas/PageInfo" }
                }
            },
            "PaginatedOrganization": {
                "type": "object",
                "required": ["data", "page_info"],
                "properties": {
                    "data": { "type": "array", "items": { "$ref": "#/components/schemas/Organization" } },
                    "page_info": { "$ref": "#/components/schemas/PageInfo" }
                }
            },
            "PaginatedRepository": {
                "type": "object",
                "required": ["data", "page_info"],
                "properties": {
                    "data": { "type": "array", "items": { "$ref": "#/components/schemas/Repository" } },
                    "page_info": { "$ref": "#/components/schemas/PageInfo" }
                }
            },
            "PatchApiKeyPayload": {
                "type": "object",
                "description": "Request body payload to patch a API key's metadata.",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Updates or removes the description of the API key.\n\n* If this is `null`, this will not do any patching\n* If this is a empty string, this will act as \"removing\" it from the metadata\n* If the comparsion (`old.description == this.description`) is false, then this will update it.",
                        "nullable": true
                    },
                    "name": { "allOf": [{ "$ref": "#/components/schemas/Name" }], "nullable": true }
                }
            },
            "PatchOrganizationPayload": {
                "type": "object",
                "description": "Request body payload for patching an organization's metadata.",
                "properties": {
                    "display_name": {
                        "type": "string",
                        "description": "Display name for this organization.",
                        "nullable": true
                    },
                    "gravatar_email": {
                        "type": "string",
                        "description": "Optional field to update this organization's gravatar email. If this organization doesn't\nhave an avatar that is used or prefers not to use their previously uploaded\navatars and they set their Gravatar email, their Gravatar will be used.",
                        "nullable": true
                    },
                    "name": { "allOf": [{ "$ref": "#/components/schemas/Name" }], "nullable": true },
                    "private": {
                        "type": "boolean",
                        "description": "Whether if the organization is private or not.",
                        "nullable": true
                    },
                    "twitter_handle": {
                        "type": "string",
                        "description": "Adds or removes a Twitter handle from this organization's metadata.\n\n* If this is `null`, this will not do any patching\n* If this is a empty string, this will act as \"removing\" it from the metadata\n* If the comparsion (`old.twitter_handle == twitter_handle`) is false, then this will update it.",
                        "nullable": true
                    }
                }
            },
            "PatchRepositoryPayload": {
                "type": "object",
                "description": "Payload to patch a repository's metadata.",
                "required": ["name"],
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Short description about this repository. If `description` was set to `null`, then\nthis will not be updated, if `description` was a empty string, the `description`\nwill be set to a empty string and will present as \"*no description for this repository*\"\nin Hoshi.",
                        "nullable": true
                    },
                    "name": { "$ref": "#/components/schemas/Name" },
                    "private": {
                        "type": "boolean",
                        "description": "Whether if this repository is private. This cannot be set to the actual value\nthat it was previously.",
                        "nullable": true
                    },
                    "readme": {
                        "type": "string",
                        "description": "The contents of the README that will be displayed on the repository. If you're\nusing charted's official Helm plugin, new releases can update its README and it'll\nbe reflected.\n\nThis should be valid Markdown, but XSS cross scripting is impossible as scripts\nin codeblocks or via `<script>` won't be executed.\n\nYou can retrieve a repository's README (if it is public or if you have access) with\nthe [`GET /cdn`](https://charts.noelware.org/docs/server/latest/api/cdn#GET-{...params}) REST\nendpoint if the instance has the CDN feature enabled. It'll be under `/repositories/{id}/README.md`.",
                        "nullable": true
                    },
                    "type": { "allOf": [{ "$ref": "#/components/schemas/ChartType" }], "nullable": true }
                }
            },
            "PatchUserConnectionsPayload": {
                "type": "object",
                "description": "Represents the request payload for updating a user's connection.",
                "properties": {
                    "github_account_id": {
                        "type": "string",
                        "description": "Account ID that was sourced from GitHub OAuth2. This can differ from\nGitHub (https://github.com) and GitHub Enterprise usage.",
                        "nullable": true
                    },
                    "google_account_id": {
                        "type": "string",
                        "description": "Account ID that was sourced from Google OAuth2",
                        "nullable": true
                    },
                    "noelware_account_id": {
                        "type": "integer",
                        "format": "int64",
                        "description": "Snowflake ID that was sourced from [Noelware's Accounts System](https://accounts.noelware.org)",
                        "nullable": true,
                        "minimum": 0
                    }
                }
            },
            "PatchUserPayload": {
                "type": "object",
                "description": "Payload for patching your user metadata.",
                "required": ["username", "password"],
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Short description about this user. If this field was provided, then the\ndescription will be overwritten. If this field is `null`, then nothing\nwill happen. If this field is a empty string, then the description\nwill be wiped.",
                        "nullable": true
                    },
                    "email": { "type": "string", "description": "Updates this user's email.", "nullable": true },
                    "gravatar_email": {
                        "type": "string",
                        "description": "Optional field to update this user's gravatar email. If this user doesn't\nhave an avatar that is used or prefers not to use their previously uploaded\navatars and they set their Gravatar email, their Gravatar will be used.",
                        "nullable": true
                    },
                    "name": { "type": "string", "description": "Updates this user's display name.", "nullable": true },
                    "password": { "$ref": "#/components/schemas/password" },
                    "username": { "allOf": [{ "$ref": "#/components/schemas/Name" }], "nullable": true }
                }
            },
            "Repository": {
                "type": "object",
                "required": ["created_at", "updated_at", "owner", "name", "type", "id"],
                "properties": {
                    "created_at": { "$ref": "#/components/schemas/DateTime" },
                    "creator": {
                        "type": "integer",
                        "format": "int64",
                        "description": "Unique identifier for a resource. Based off the [Twitter Snowflake](https://blog.twitter.com/engineering/en_us/a/2010/announcing-snowflake) spec.",
                        "minLength": 15
                    },
                    "deprecated": {
                        "type": "boolean",
                        "description": "Whether if this repository is deprecated or not"
                    },
                    "description": {
                        "type": "string",
                        "description": "Short description about this user, can be `null` if none was provided.",
                        "nullable": true
                    },
                    "icon_hash": {
                        "type": "string",
                        "description": "Unique hash to locate a repository's icon, this also includes the extension that this avatar is, i.e, `png`.",
                        "nullable": true
                    },
                    "id": {
                        "type": "integer",
                        "format": "int64",
                        "description": "Unique identifier for a resource. Based off the [Twitter Snowflake](https://blog.twitter.com/engineering/en_us/a/2010/announcing-snowflake) spec.",
                        "minLength": 15
                    },
                    "name": { "$ref": "#/components/schemas/Name" },
                    "owner": {
                        "type": "integer",
                        "format": "int64",
                        "description": "Unique identifier for a resource. Based off the [Twitter Snowflake](https://blog.twitter.com/engineering/en_us/a/2010/announcing-snowflake) spec.",
                        "minLength": 15
                    },
                    "private": { "type": "boolean", "description": "Whether if this repository is private or not" },
                    "type": { "$ref": "#/components/schemas/ChartType" },
                    "updated_at": { "$ref": "#/components/schemas/DateTime" }
                }
            },
            "RepositoryRelease": {
                "type": "object",
                "description": "Represents a resource that contains a release from a [Repository] release. Releases\nare a way to group releases of new versions of Helm charts that can be easily\nfetched from the API server.\n\nAny repository can have an unlimited amount of releases, but tags cannot clash\ninto each other, so the API server will not accept it. Each tag should be\na SemVer 2 comformant string, parsing is related to how Cargo evaluates SemVer 2 tags.",
                "required": ["repository", "created_at", "updated_at", "tag", "id"],
                "properties": {
                    "created_at": { "$ref": "#/components/schemas/DateTime" },
                    "id": {
                        "type": "integer",
                        "format": "int64",
                        "description": "Unique identifier for a resource. Based off the [Twitter Snowflake](https://blog.twitter.com/engineering/en_us/a/2010/announcing-snowflake) spec.",
                        "minLength": 15
                    },
                    "is_prerelease": {
                        "type": "boolean",
                        "description": "Whether if this release is a pre-release or not."
                    },
                    "repository": {
                        "type": "integer",
                        "format": "int64",
                        "description": "Unique identifier for a resource. Based off the [Twitter Snowflake](https://blog.twitter.com/engineering/en_us/a/2010/announcing-snowflake) spec.",
                        "minLength": 15
                    },
                    "tag": { "$ref": "#/components/schemas/Version" },
                    "update_text": {
                        "type": "string",
                        "description": "Markdown-formatted string that contains a changelog of this release.",
                        "nullable": true
                    },
                    "updated_at": { "$ref": "#/components/schemas/DateTime" }
                }
            },
            "Session": {
                "type": "object",
                "required": ["session", "user"],
                "properties": {
                    "access_token": {
                        "type": "string",
                        "description": "Access token. This will always be `null` if queried, but always will\nbe present if you successfully logged in.",
                        "nullable": true
                    },
                    "refresh_token": {
                        "type": "string",
                        "description": "Refresh token. This will always be `null` if queried, but always will\nbe present if you successfully logged in.",
                        "nullable": true
                    },
                    "session": { "type": "string", "format": "uuid", "description": "UUID of the session." },
                    "user": {
                        "type": "integer",
                        "format": "int64",
                        "description": "ID of the user that created this session.",
                        "minimum": 0
                    }
                }
            },
            "Snowflake": {
                "type": "integer",
                "format": "int64",
                "description": "Unique identifier for a resource. Based off the [Twitter Snowflake](https://blog.twitter.com/engineering/en_us/a/2010/announcing-snowflake) spec.",
                "minLength": 15
            },
            "StringOrImportValue": {
                "oneOf": [
                    { "type": "string", "description": "String that points to a key to be imported." },
                    { "$ref": "#/components/schemas/ImportValue" }
                ],
                "description": "Union enum that can contain a String or a [ImportValue] as the import source\nfor referencing parent key items to be imported."
            },
            "User": {
                "type": "object",
                "description": "Represents an account that can own [repositories][Repository] and [organizations][Organizations]",
                "required": ["created_at", "updated_at", "username", "id"],
                "properties": {
                    "admin": {
                        "type": "boolean",
                        "description": "Whether if this User is an Administrator of this instance"
                    },
                    "avatar_hash": {
                        "type": "string",
                        "description": "Unique hash to locate a user's avatar, this also includes the extension that this avatar is, i.e, `png`.",
                        "nullable": true
                    },
                    "created_at": { "$ref": "#/components/schemas/DateTime" },
                    "description": {
                        "type": "string",
                        "description": "Short description about this user, can be `null` if none was provided.",
                        "nullable": true
                    },
                    "gravatar_email": {
                        "type": "string",
                        "description": "Valid email address that points to a Gravatar avatar, or `null` if it shouldn't use one as the primary avatar",
                        "nullable": true
                    },
                    "id": {
                        "type": "integer",
                        "format": "int64",
                        "description": "Unique identifier for a resource. Based off the [Twitter Snowflake](https://blog.twitter.com/engineering/en_us/a/2010/announcing-snowflake) spec.",
                        "minLength": 15
                    },
                    "name": {
                        "type": "string",
                        "description": "A valid UTF-8 string that is used to identify a resource from the REST API in a humane fashion. This is meant to help identify a resource without trying to calculate the resource's Snowflake on the first try.",
                        "maxLength": 32,
                        "minLength": 1,
                        "pattern": "([A-z]|-|_|\\d{0,9}){1,32}"
                    },
                    "updated_at": { "$ref": "#/components/schemas/DateTime" },
                    "username": { "$ref": "#/components/schemas/Name" },
                    "verified_publisher": {
                        "type": "boolean",
                        "description": "Whether if this User is a Verified Publisher or not."
                    }
                }
            },
            "UserConnections": {
                "type": "object",
                "description": "Represents a collection of a user's connections that can be used\nto login from different sources (like GitHub OAuth2)",
                "required": ["created_at", "updated_at", "id"],
                "properties": {
                    "created_at": { "$ref": "#/components/schemas/DateTime" },
                    "github_account_id": {
                        "type": "string",
                        "description": "Account ID that was sourced from GitHub OAuth2. This can differ from\nGitHub (https://github.com) and GitHub Enterprise usage.",
                        "nullable": true
                    },
                    "google_account_id": {
                        "type": "string",
                        "description": "Account ID that was sourced from Google OAuth2",
                        "nullable": true
                    },
                    "id": {
                        "type": "integer",
                        "format": "int64",
                        "description": "Unique identifier for a resource. Based off the [Twitter Snowflake](https://blog.twitter.com/engineering/en_us/a/2010/announcing-snowflake) spec.",
                        "minLength": 15
                    },
                    "noelware_account_id": {
                        "type": "integer",
                        "format": "int64",
                        "description": "Snowflake ID that was sourced from [Noelware's Accounts System](https://accounts.noelware.org)",
                        "nullable": true
                    },
                    "updated_at": { "$ref": "#/components/schemas/DateTime" }
                }
            },
            "UserLoginPayload": {
                "type": "object",
                "description": "Payload to login as a user from the `GET /users/login` endpoint for session-based\nauthentication.",
                "required": ["password"],
                "properties": {
                    "email": {
                        "type": "string",
                        "description": "Email to authenticate as. This is mutually exclusive with `username`.",
                        "nullable": true
                    },
                    "password": { "$ref": "#/components/schemas/password" },
                    "username": { "allOf": [{ "$ref": "#/components/schemas/Name" }], "nullable": true }
                }
            },
            "Version": {
                "type": "string",
                "description": "Represents a [semantic version](https://semver.org) that both Helm and charted-server accept as versions for Helm charts",
                "pattern": "^(?P<major>0|[1-9]\\d*)\\.(?P<minor>0|[1-9]\\d*)\\.(?P<patch>0|[1-9]\\d*)(?:-(?P<prerelease>(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$"
            },
            "VersionReq": {
                "type": "string",
                "description": "Represents a semantic version (https://semver.org) requirement (i.e, `>=1.2.0`) that Helm and charted-server will only accept"
            }
        },
        "responses": {
            "ApiErrorResponse": {
                "description": "API response that doesn't contain any data",
                "content": {
                    "application/json": {
                        "schema": {
                            "type": "object",
                            "required": ["success", "errors"],
                            "properties": {
                                "errors": {
                                    "type": "array",
                                    "items": { "$ref": "#/components/schemas/Error" },
                                    "description": "List of errors on why the request failed."
                                },
                                "success": {
                                    "type": "boolean",
                                    "description": "whether if this response [ApiErrorResponse] was a success or not"
                                }
                            }
                        }
                    }
                }
            },
            "ApiKeyPaginatedResponse": {
                "description": "Response object for \"PaginatedApiKey\"",
                "content": {
                    "application/json": {
                        "schema": {
                            "type": "object",
                            "required": ["success", "data"],
                            "properties": {
                                "data": { "$ref": "#/components/schemas/PaginatedApiKey" },
                                "success": {
                                    "type": "boolean",
                                    "description": "whether if this response [ApiKeyPaginatedResponse] was successful or not"
                                }
                            }
                        }
                    }
                }
            },
            "ApiKeyResponse": {
                "description": "Response object for \"ApiKey\"",
                "content": {
                    "application/json": {
                        "schema": {
                            "type": "object",
                            "required": ["success", "data"],
                            "properties": {
                                "data": { "$ref": "#/components/schemas/ApiKey" },
                                "success": {
                                    "type": "boolean",
                                    "description": "whether if this response [ApiKeyResponse] was successful or not"
                                }
                            }
                        }
                    }
                }
            },
            "EmptyApiResponse": {
                "description": "API response that doesn't contain any data",
                "content": {
                    "application/json": {
                        "schema": {
                            "type": "object",
                            "required": ["success"],
                            "properties": {
                                "success": {
                                    "type": "boolean",
                                    "description": "whether if this response [EmptyApiResponse] was a success or not"
                                }
                            }
                        }
                    }
                }
            },
            "EntrypointResponse": {
                "description": "Response object for \"EntrypointResponse\"",
                "content": {
                    "application/json": {
                        "schema": {
                            "type": "object",
                            "required": ["success", "data"],
                            "properties": {
                                "data": { "$ref": "#/components/schemas/EntrypointResponse" },
                                "success": {
                                    "type": "boolean",
                                    "description": "whether if this response [EntrypointResponse] was successful or not"
                                }
                            }
                        }
                    }
                }
            },
            "FeaturesResponse": {
                "description": "Response object for \"FeaturesResponse\"",
                "content": {
                    "application/json": {
                        "schema": {
                            "type": "object",
                            "required": ["success", "data"],
                            "properties": {
                                "data": { "$ref": "#/components/schemas/FeaturesResponse" },
                                "success": {
                                    "type": "boolean",
                                    "description": "whether if this response [FeaturesResponse] was successful or not"
                                }
                            }
                        }
                    }
                }
            },
            "InfoResponse": {
                "description": "Response object for \"InfoResponse\"",
                "content": {
                    "application/json": {
                        "schema": {
                            "type": "object",
                            "required": ["success", "data"],
                            "properties": {
                                "data": { "$ref": "#/components/schemas/InfoResponse" },
                                "success": {
                                    "type": "boolean",
                                    "description": "whether if this response [InfoResponse] was successful or not"
                                }
                            }
                        }
                    }
                }
            },
            "MainResponse": {
                "description": "Response object for \"MainResponse\"",
                "content": {
                    "application/json": {
                        "schema": {
                            "type": "object",
                            "required": ["success", "data"],
                            "properties": {
                                "data": { "$ref": "#/components/schemas/MainResponse" },
                                "success": {
                                    "type": "boolean",
                                    "description": "whether if this response [MainResponse] was successful or not"
                                }
                            }
                        }
                    }
                }
            },
            "MemberPaginatedResponse": {
                "description": "Response object for \"PaginatedMember\"",
                "content": {
                    "application/json": {
                        "schema": {
                            "type": "object",
                            "required": ["success", "data"],
                            "properties": {
                                "data": { "$ref": "#/components/schemas/PaginatedMember" },
                                "success": {
                                    "type": "boolean",
                                    "description": "whether if this response [MemberPaginatedResponse] was successful or not"
                                }
                            }
                        }
                    }
                }
            },
            "OrganizationPaginatedResponse": {
                "description": "Response object for \"PaginatedOrganization\"",
                "content": {
                    "application/json": {
                        "schema": {
                            "type": "object",
                            "required": ["success", "data"],
                            "properties": {
                                "data": { "$ref": "#/components/schemas/PaginatedOrganization" },
                                "success": {
                                    "type": "boolean",
                                    "description": "whether if this response [OrganizationPaginatedResponse] was successful or not"
                                }
                            }
                        }
                    }
                }
            },
            "RepositoryPaginatedResponse": {
                "description": "Response object for \"PaginatedRepository\"",
                "content": {
                    "application/json": {
                        "schema": {
                            "type": "object",
                            "required": ["success", "data"],
                            "properties": {
                                "data": { "$ref": "#/components/schemas/PaginatedRepository" },
                                "success": {
                                    "type": "boolean",
                                    "description": "whether if this response [RepositoryPaginatedResponse] was successful or not"
                                }
                            }
                        }
                    }
                }
            },
            "RepositoryResponse": {
                "description": "Response object for \"Repository\"",
                "content": {
                    "application/json": {
                        "schema": {
                            "type": "object",
                            "required": ["success", "data"],
                            "properties": {
                                "data": { "$ref": "#/components/schemas/Repository" },
                                "success": {
                                    "type": "boolean",
                                    "description": "whether if this response [RepositoryResponse] was successful or not"
                                }
                            }
                        }
                    }
                }
            },
            "SessionResponse": {
                "description": "Response object for \"Session\"",
                "content": {
                    "application/json": {
                        "schema": {
                            "type": "object",
                            "required": ["success", "data"],
                            "properties": {
                                "data": { "$ref": "#/components/schemas/Session" },
                                "success": {
                                    "type": "boolean",
                                    "description": "whether if this response [SessionResponse] was successful or not"
                                }
                            }
                        }
                    }
                }
            },
            "UserResponse": {
                "description": "Response object for \"User\"",
                "content": {
                    "application/json": {
                        "schema": {
                            "type": "object",
                            "required": ["success", "data"],
                            "properties": {
                                "data": { "$ref": "#/components/schemas/User" },
                                "success": {
                                    "type": "boolean",
                                    "description": "whether if this response [UserResponse] was successful or not"
                                }
                            }
                        }
                    }
                }
            }
        },
        "securitySchemes": {
            "ApiKey": { "type": "apiKey", "in": "header", "name": "ApiKey" },
            "Basic": {
                "type": "http",
                "scheme": "basic",
                "description": "> WARN: On some instances, this is disabled\n\nAllows the use of the HTTP Basic Auth scheme to use authenticated endpoints as a user."
            },
            "Bearer": {
                "type": "http",
                "scheme": "bearer",
                "description": "Signed JWT that is made to safely be authenticated"
            }
        }
    },
    "externalDocs": {
        "url": "https://charts.noelware.org/docs/server/0.1.0-beta",
        "description": "Main documentation source for charted-server"
    }
}
