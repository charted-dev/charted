// ðŸ“¦ charted-server: Free, open source, and reliable Helm Chart registry made in Kotlin.
// Copyright 2022-2023 Noelware <team@noelware.org>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package api

import (
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"

	"charts.noelware.org/tools/helm-plugin/pkg/cli"
	"charts.noelware.org/tools/helm-plugin/pkg/constants"
	"charts.noelware.org/tools/helm-plugin/pkg/verbose"
)

// Method represents an HTTP method verb
type Method string

var (
	MethodGET    Method = "GET"
	MethodPUT    Method = "PUT"
	MethodHEAD   Method = "HEAD"
	MethodPOST   Method = "POST"
	MethodPATCH  Method = "PATCH"
	MethodDELETE Method = "DELETE"
)

func (m Method) String() string {
	switch m {
	case MethodGET:
		return "GET"
	case MethodPUT:
		return "PUT"
	case MethodPOST:
		return "POST"
	case MethodHEAD:
		return "HEAD"
	case MethodPATCH:
		return "PATCH"
	case MethodDELETE:
		return "DELETE"
	default:
		return "?"
	}
}

// Api is the global request factory for creating requests to charted-server. At the moment, this would've been
// generated by OpenAPI Generator Tools, but at the moment, the OpenAPI spec is not finalized.
type Api struct {
	serverUrl string
	client    *http.Client
	log       *verbose.VerboseLogger
}

// NewApi returns a new *Api instance.
func NewApi(o *cli.GlobalOptions) *Api {
	return &Api{
		serverUrl: o.ServerUrl,
		client:    http.DefaultClient,
		log:       o.Log(),
	}
}

// IsAvailable sends out a request to the /heartbeat endpoint to check if the server is well.
func (api *Api) IsAvailable() (bool, error) {
	status, err := api.Head("/heartbeat", nil)
	if err != nil {
		return false, err
	}

	return status == 200, nil
}

func (api *Api) Get(endpoint string, data any) (int, error) {
	return api.request(endpoint, MethodGET, data, nil)
}

func (api *Api) Put(endpoint string, data any, body io.ReadCloser) (int, error) {
	return api.request(endpoint, MethodPUT, data, body)
}

func (api *Api) Head(endpoint string, data any) (int, error) {
	return api.request(endpoint, MethodHEAD, data, nil)
}

func (api *Api) Post(endpoint string, data any, body io.ReadCloser) (int, error) {
	return api.request(endpoint, MethodPOST, data, body)
}

func (api *Api) Patch(endpoint string, data any, body io.ReadCloser) (int, error) {
	return api.request(endpoint, MethodPATCH, data, body)
}

func (api *Api) Delete(endpoint string, data any, body io.ReadCloser) (int, error) {
	return api.request(endpoint, MethodDELETE, data, body)
}

// request sends out a request to the server URL that returns a tuple of (StatusCode, error?)
func (api *Api) request(endpoint string, method Method, data any, body io.ReadCloser) (int, error) {
	api.log.Printf("%s %s", method.String(), endpoint)

	// Validate if method can send out payloads or not
	if method == MethodGET || method == MethodHEAD {
		if body != nil {
			return 0, fmt.Errorf("request method %s cannot include a request body", method.String())
		}
	}

	url, err := url.Parse(fmt.Sprintf("%s/%s", api.serverUrl, endpoint))
	if err != nil {
		return 0, err
	}

	headers := make(http.Header)
	headers["User-Agent"] = []string{fmt.Sprintf("Noelware/charted-helm-plugin (+https://github.com/charted-dev/charted/tree/main/tools/helm-plugin; v%s+%s", constants.Version, constants.CommitSHA)}

	req := &http.Request{
		Method: method.String(),
		Header: headers,
		Body:   body,
		URL:    url,
	}

	res, err := api.client.Do(req)
	if err != nil {
		return 0, err
	}

	api.log.Printf("%s %s => %d[%s]", endpoint, method.String(), res.StatusCode, res.Proto)
	if data == nil {
		return res.StatusCode, nil
	}

	defer res.Body.Close()

	if err := json.NewDecoder(res.Body).Decode(data); err != nil {
		if errors.Is(err, io.EOF) {
			api.log.Print("unexpected eof occurred")
		}

		return res.StatusCode, err
	}

	return res.StatusCode, nil
}
